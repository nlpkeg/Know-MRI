import json
import os
import sys
import socket
import base64
import copy
from pathlib import Path
base_dir = str(Path(__file__).absolute().parent.parent)
if base_dir not in sys.path:
    sys.path.append(base_dir)
import util
import traceback
from flask import Flask, Response, jsonify, request,render_template
from flask_cors import *
from dataset_process import dataset_list, name2dataset_module
from models import support_models
from methods.assist import sort_methods_by_cost_time
from methods.assist import get_methods_by_dataset_and_model_name
from methods import method_name2sub_module
from diagnose.diagnose import diagnosing, get_model_output
from util.fileutil import image_dict_to_base64
from util.visualizing import get_echarts_info_with_result
from util.model_tokenizer import get_cached_model_tok
from util.cache_process import read_cache, write_cache, generate_cache_key
from embedding_utils.Vectordb import Interpret_vectordb
import random
import argparse
from openai import OpenAI
from util.openai_generate_data import system_prompt, str2dic
random.seed(1)

# server port
root_port = int(os.environ.get("PORT", 11008))

class InterpretGUIFlask:
    
    def __init__(self, args):
        
        # init flask_app
        self.app = Flask(__name__, static_url_path='')
        self.app.config['JSON_AS_ASCII'] = False
        self.vecdb = Interpret_vectordb(args.vecdb_config_path)
        self.gpt4o = OpenAI(base_url=args.openai_base_url, 
                            api_key=args.openai_api_key)
        
        CORS(self.app, resources={r"/*": {"origins": "*"}}, send_wildcard=True)

        @self.app.get('/')
        def home():
            return render_template('index.html')

        @self.app.get('/getip')
        def getip():
            def get_local_ip():
                try:
                    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
                    s.connect(('8.8.8.8', 80))
                    local_ip = s.getsockname()[0]
                except Exception as e:
                    # If the IP address cannot be obtained correctly, please manually change it to the IP address of the deployment machine.
                    local_ip = '127.0.0.1'
                finally:
                    s.close()
                return local_ip
            
            ip = "http://" + str(get_local_ip()).strip() + ":" + str(root_port).strip()
            
            return jsonify({"data": ip, "code": 200})


        @self.app.get('/loadModelByName')
        def loadModelByName():
            try:
                model_name = request.args.get('modelName')
                print('-------------model_name----------------\n',model_name)
                get_cached_model_tok(model_name=model_name)
                return jsonify({"data": "OK", "code": 200})
            except Exception as e:
                traceback.print_exc()
                return jsonify({"data": [], "code": 500})

        @self.app.get('/getDatasetList')
        def getDatasetList():
            try: 
                tem_list = []
                for data_name in dataset_list:
                    if data_name['name'] != 'GPT4o_data':
                        tem_list.append(data_name)

                return jsonify({"data": tem_list, "code": 200})
            except Exception as e:
                traceback.print_exc()
                return jsonify({"data": [], "code": 500})
            
            
        @self.app.post('/searchTopnByInput')
        def searchTopnByInput():
            jsondata = request.get_json()
            input_text = jsondata["input_text"]
            try:
                data_list = []
                try: 
                    if args.openai_api_key:
                        gptdata = self.gpt4o.chat.completions.create(messages=[{"role": "system", "content": system_prompt}, 
                                                                            {"role": "user", "content": input_text}], model="gpt-4o")
                        print("---The data generated by GPT-4o---")
                        print(gptdata.choices[0].message.content)
                        gpt_dic = str2dic(gptdata.choices[0].message.content)
                        gpt_dic["prompts"] = [gpt_dic["prompt"]]
                        name2dataset_module["GPT4o_data"].support_template_keys = list(gpt_dic.keys())
                        gpt_dic["dataset_name"] = "GPT4o_data"
                        data_list.append(gpt_dic)
                except:
                    print("GPT4o generated data error!")
                
                
                res = self.vecdb.search(input_text)[0]
                """
                data_list.append({
                        "dataset_name": input_text+"测试 dataset_name"+str(i),
                        "dataset_type":input_text+"测试 dataset_type"+str(i),
                        "prompt":(input_text+"测试 prompt"+str(i))*5,
                        "ground_truth":input_text+"测试 ground_truth"+str(i),
                        # ....
                    })
                """
                for r in res:
                    r["entity"]["data"]["dataset_name"] = r["entity"]["info"]
                    data_list.append(r["entity"]["data"])
                        
                return jsonify({"data": data_list, "code": 200})
            except Exception as e:
                traceback.print_exc()
                return jsonify({"data": [], "code": 500})
            
        @self.app.get('/getModelList')
        def getModelList():
            try:
                model_list = support_models                
                return jsonify({"data": model_list, "code": 200})
            except Exception as e:
                traceback.print_exc()
                return jsonify({"data": [], "code": 500})
            
        @self.app.get('/getMethodListByModelName')
        def getMethodListByModelName():
            try:
                dataset_name = request.args.get('dataset_name')
                model_name = request.args.get('model_name')
                print('-------------dataset_name----------------\n',dataset_name)
                print('-------------model_name----------------\n',model_name)
                
                try:
                    method_list = get_methods_by_dataset_and_model_name(dataset_name=dataset_name,model_name=model_name)
                except:
                    traceback.print_exc()
                    method_list = []
                
                """
                method_list = [
                    {
                        "value": "External",
                        "label": "External",
                        "children":[
                            {
                                "value": "method_typexxx1",
                                "label": "method_typexxx1",
                                "children":[
                                    {
                                        "value": "Attribution1",
                                        "label": "Attribution1",
                                    },
                                    {
                                        "value": "111",
                                        "label": "111",
                                    },
                                ]
                            },
                            {
                                "value": "method_typexxx2",
                                "label": "method_typexxx2",
                                "children":[
                                    {
                                        "value": "Attribution2",
                                        "label": "Attribution2",
                                    },
                                    {
                                        "value": "222",
                                        "label": "222",
                                    },
                                ]
                            }
                        ]
                    },
                    {
                        "value": "Internal",
                        "label": "Internal",
                        "children":[
                            {
                                "value": "method_typexxx3",
                                "label": "method_typexxx3",
                                "children":[
                                    {
                                        "value": "Attribution3",
                                        "label": "Attribution3",
                                    },
                                    {
                                        "value": "333",
                                        "label": "333",
                                    },
                                ]
                            },
                            {
                                "value": "method_typexxx4",
                                "label": "method_typexxx4",
                                "children":[
                                    {
                                        "value": "Attribution4",
                                        "label": "Attribution4",
                                    },
                                    {
                                        "value": "444",
                                        "label": "444",
                                    },
                                ]
                            }
                        ]
                    },
                ]
                """

                base_method_dic = [{"value": "External", "label": "External", "children": []}, {"value": "Internal", "label": "Internal", "children": []}]
                for method in method_list:
                    sub_mod = method_name2sub_module[method]
                    data = base_method_dic
                    for pa in sub_mod.path:
                        create = True
                        for teda in data:
                            if teda["value"] == pa:
                                data = teda["children"]
                                create = False
                                break
                        if create:
                            data.append({"value": pa, "label": pa, "children": []})
                            for teda in data:
                                if teda["value"] == pa:
                                    data = teda["children"]
                                    create = False
                                    break
                    data.append({"value": method, "label": method})
                
                return jsonify({"data": base_method_dic, "code": 200})
            except Exception as e:
                traceback.print_exc()
                return jsonify({"data": [], "code": 500})
            
        @self.app.get('/getDatasetDataTopnByName')
        def getDatasetDataTopnByName():
            try:
                dataset_name = request.args.get('dataset_name')
                print('-------------dataset_name----------------\n',dataset_name)
                if dataset_name == "USEREDITINPUT":
                    data_list = []
                else:
                    data_list = name2dataset_module[dataset_name].get_default_dataset().samples()
                
                return jsonify({"data": data_list, "code": 200})
            except Exception as e:
                traceback.print_exc()
                return jsonify({"data": [], "code": 500})
            
        @self.app.get('/getDatasetDataRandom1ByName')
        def getDatasetDataRandom1ByName():
            try:
                dataset_name = request.args.get('dataset_name')
                print('-------------dataset_name----------------\n',dataset_name)
                if dataset_name == "USEREDITINPUT":
                    data_obj = {}
                else:
                    data_obj = name2dataset_module[dataset_name].get_default_dataset().samples(n=1)[0]
                return jsonify({"data": data_obj, "code": 200})
            except Exception as e:
                traceback.print_exc()
                return jsonify({"data": {}, "code": 500})
            
            
        # @self.app.post('/do_generate')
        # def do_generate():
        #     jsondata = request.get_json()
        #     dataset_name = jsondata["dataset_name"]
        #     model_name = jsondata["model_name"]
        #     method_name_list = jsondata["method_name"]
        #     input_data = jsondata["input"]
        #     # kwargs = jsondata['kwargs']
            
        #     if dataset_name == "USEREDITINPUT":
        #         print("The data entered by the user themselves, not using the data from the dataset.")
        #         input_data = name2dataset_module[dataset_name].get_processed_kvs(input_data)
        #         print(input_data)
        #     try:
        #         combine_result = {
        #             "result": "Model output results",
        #             "external": {},
        #             "internal": {}
        #         }
        #         combine_result["result"] = get_model_output(sample=input_data, model_name_or_path=model_name)
        #         for method_name in method_name_list:
        #             result = diagnosing(sample=input_data, model_name_or_path=model_name, method=method_name)
        #             if "image" in result:
        #                 result["img"] = r"data:image/png;base64," + image_to_base64(result["image"])
        #             combine_result["internal"][method_name] = result
        #         return jsonify({"data": combine_result, "code": 200})
        #     except Exception as e:
        #         traceback.print_exc()
        #         combine_result = {
        #             "result": f"dataset: {dataset_name}, model: {model_name},method: {method_name_list},input: {input_data}, output results: output results examples",
        #             "external": {},
        #             "internal": {}
        #         }
        #         return jsonify({"data": combine_result, "code": 500})


        @self.app.post('/do_generate_stream')
        def do_generate_stream():
            jsondata = request.get_json()
            dataset_name = jsondata["dataset_name"]
            model_name = jsondata["model_name"]
            tem_method_name_list = jsondata["method_name"]
            input_data = jsondata["input"]

            if dataset_name == "USEREDITINPUT":
                print("The data entered by the user themselves, not using the data from the dataset.")
                input_data = name2dataset_module[dataset_name].get_processed_kvs(input_data)
                print(input_data)
            
            print("---------------The backend has received the stream!!!---------------")
            print("dataset_name: \n",dataset_name)
            print("model_name: \n",model_name)
            print("method_name_list: \n",tem_method_name_list)
            print("input_data: \n",input_data)
            
            def generate():
                
                combine_result = {
                    "result": "Model output",
                    # "external": {},
                    # "internal": {}
                }      
                     
                """
                combine_result = {
                    "result": "",
                    "External": {
                        "Attribution": {
                            "Attribution": {}
                        }
                    },
                    "Internal": {
                        "neuron attribution": {
                            "KN": {},
                            "FINE": {}
                        },
                        "hiddenstates": {
                            "Factual_recall": {}
                        },
                        "MLP": {
                            "CausalTracing": {}
                        }
                    }
                }
                """
                     
                combine_result["result"] = get_model_output(sample=input_data, model_name_or_path=model_name)
                # ----------------------------Begin method invocation---------------------------------
                method_name_list = [m[-1] for m in tem_method_name_list]
                for method_name in sort_methods_by_cost_time(method_name_list):
                    result = {"text": "", "imgs": [], "table": [], "echarts": []}
                    try:
                        cache_key = generate_cache_key(sample=input_data, method_name=method_name, model_name=model_name)
                        cache_data, in_cache = read_cache(key=cache_key)
                        if in_cache:
                            result_ = cache_data
                        else:
                            result_ = diagnosing(sample=input_data, model_name_or_path=model_name, method=method_name)
                            write_cache(key=cache_key, data=result_)
                        result.update(copy.deepcopy(result_))
                        result["echarts"] = get_echarts_info_with_result(result=result, method_name=method_name, model_name=model_name)
                        result["imgs"] = [image_dict_to_base64(image_dict) for image_dict in result.get("image", [])]
                        for tab in result["table"]:
                            if "table_des" in tab:
                                tab["des"] = tab["table_des"]
                            if "table_res" in tab:
                                tab["res"] = tab["table_res"]
                        # if "result_des" in result:
                        #     result["text"] = result["result_des"]
                        result.pop("origin_data") # useless
                        if method_name2sub_module[method_name].external_internal not in combine_result:
                            combine_result[method_name2sub_module[method_name].external_internal] = {}
                        if method_name2sub_module[method_name].interpret_class not in combine_result[method_name2sub_module[method_name].external_internal]:
                            combine_result[method_name2sub_module[method_name].external_internal][method_name2sub_module[method_name].interpret_class] = {}
                        combine_result[method_name2sub_module[method_name].external_internal][method_name2sub_module[method_name].interpret_class][method_name] = result
                        print(f"{method_name}-{model_name} is processed")
                    except Exception as e:
                        traceback.print_exc()
                        continue         
                    # ---------------------------Method invocation ended-----------------------------
                    # yield json.dumps(combine_result,ensure_ascii=False)  +"\n\n"  
                    original_string = json.dumps(combine_result,ensure_ascii=False)
                    encoded_bytes = base64.b64encode(original_string.encode('utf-8'))
                    encoded_string = encoded_bytes.decode('utf-8')
                    yield f"{encoded_string}\n\n"
                
                # yield "END\n\n"
                
                original_string = "END"
                encoded_bytes = base64.b64encode(original_string.encode('utf-8'))
                encoded_string = encoded_bytes.decode('utf-8')
                yield f"{encoded_string}\n\n"
                
            return Response(generate(), mimetype='text/event-stream')

    # run 
    def run(self, host, port):
        self.app.run(host=host, port=port,threaded=True)

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument('--vecdb_config_path', default="../embedding_utils/embedding_setting.json", type=str)
    parser.add_argument('--openai_base_url', default="", type=str)
    parser.add_argument('--openai_api_key', default="", type=str)
    args = parser.parse_args()
    my_flask_app = InterpretGUIFlask(args)
    my_flask_app.run(host='0.0.0.0', port=root_port)
    